#!/usr/bin/env -S uv run --quiet --with tidalapi==0.8.4
# /// script
# dependencies = ["tidalapi==0.8.4"]
# ///
"""
Tidal DNA: Create a playlist with an artist-by-artist shuffle.

This script generates a playlist by taking a single, random top track from
each of your favorite artists, creating a unique artist-by-artist shuffle.
It uses asyncio for efficient, concurrent track fetching.
"""

import argparse
import asyncio
import logging
import random
from pathlib import Path

import tidalapi

# Set up logger
logger = logging.getLogger(__name__)


async def get_random_top_tracks(artist, count=1, semaphore=None):
    """
    Fetches a number of random top tracks for a given artist asynchronously.

    Args:
        artist: The artist object from the tidalapi.
        count (int): The number of random tracks to get.
        semaphore (asyncio.Semaphore): Used to limit concurrent requests.

    Returns:
        A list of random track objects.
    """
    async with semaphore:
        try:
            # Run the synchronous 'get_top_tracks' in a separate thread
            top_tracks = await asyncio.to_thread(artist.get_top_tracks)
            if not top_tracks:
                return []
            count = min(count, len(top_tracks))
            return random.sample(top_tracks, count)
        except Exception as e:
            logger.error(f"Couldn't get tracks for {artist.name}: {e}")
            return []


def get_or_create_playlist(session, name, description):
    """
    Gets an existing playlist by name or creates a new one.

    Args:
        session: The active tidalapi session.
        name (str): The name of the playlist.
        description (str): The description for a new playlist.

    Returns:
        A tuple containing the playlist object and a boolean indicating if it existed.
    """
    for playlist in session.user.playlists():
        if playlist.name == name:
            logger.debug(f"Found existing playlist: {name}")
            return playlist, True

    logger.debug(f"Creating new playlist: {name}")
    playlist = session.user.create_playlist(name, description=description)
    return playlist, False


def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        An argparse.Namespace object containing the arguments.
    """
    parser = argparse.ArgumentParser(
        description="Tidal DNA: Create a playlist with an artist-by-artist shuffle."
    )
    parser.add_argument(
        "--session-file",
        default=str(Path.home() / ".tidal-session-oauth.json"),
        help="Path to Tidal session file"
    )
    parser.add_argument(
        "--playlist-name",
        default="Tidal DNA",
        help="Name of the playlist"
    )
    parser.add_argument(
        "--tracks-per-artist",
        type=int,
        default=1,
        help="Number of tracks per artist"
    )
    parser.add_argument(
        "--max-tracks",
        type=int,
        help="Maximum total tracks in playlist"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    return parser.parse_args()


async def main():
    """
    The main asynchronous function to run the script logic.
    """
    args = parse_arguments()

    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(message)s')
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        # Silence tidalapi's chatter if not verbose
        logging.getLogger("tidalapi").setLevel(logging.WARNING)

    # --- Login and Playlist Setup ---
    session = tidalapi.Session()
    if not await asyncio.to_thread(session.login_session_file, Path(args.session_file)):
        logger.error("Failed to log in to Tidal")
        return

    description = "A playlist generated by Tidal DNA: an artist-by-artist shuffle of my favorite artists."
    playlist, exists = await asyncio.to_thread(
        get_or_create_playlist, session, args.playlist_name, description
    )
    logger.info(f"Using playlist: {playlist.name}")

    # --- Artist and Track Fetching ---
    favorite_artists = await asyncio.to_thread(session.user.favorites.artists)
    if not favorite_artists:
        logger.error("No favorite artists found")
        return

    random.shuffle(favorite_artists)

    # If max_tracks is set, limit the number of artists to query for efficiency.
    if args.max_tracks:
        num_artists = (args.max_tracks + args.tracks_per_artist - 1) // args.tracks_per_artist
        favorite_artists = favorite_artists[:num_artists]

    # Use a semaphore to limit concurrency and avoid overloading the server.
    semaphore = asyncio.Semaphore(10)
    tasks = [
        get_random_top_tracks(artist, args.tracks_per_artist, semaphore)
        for artist in favorite_artists
    ]
    
    all_tracks = []
    if not args.verbose:
        print("Finding tracks...", end="", flush=True)

    # Process tasks as they complete to show progress.
    for future in asyncio.as_completed(tasks):
        tracks = await future
        for track in tracks:
            all_tracks.append(track)
            logger.debug(f"Found '{track.name}' by {track.artist.name}")
            if not args.verbose:
                print(".", end="", flush=True)

    if not args.verbose:
        print()  # Newline after progress dots

    # --- Playlist Population ---
    random.shuffle(all_tracks)

    if args.max_tracks:
        all_tracks = all_tracks[:args.max_tracks]

    if all_tracks:
        track_ids = [track.id for track in all_tracks]
        
        if exists:
            logger.info("Clearing existing playlist...")
            await asyncio.to_thread(playlist.clear)
            
        logger.info(f"Adding {len(track_ids)} tracks to playlist '{playlist.name}'...")
        await asyncio.to_thread(playlist.add, track_ids)
        logger.info(f"\nDone! Added {len(track_ids)} tracks to playlist '{playlist.name}'")
    else:
        logger.info("No tracks found to add to the playlist.")


if __name__ == "__main__":
    asyncio.run(main())
